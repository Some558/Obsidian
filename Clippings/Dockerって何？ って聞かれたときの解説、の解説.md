---
title: "Dockerって何？ って聞かれたときの解説、の解説"
source: "https://zenn.dev/koduki/articles/b4cb0551523919"
author:
  - "[[Zenn]]"
published: 2021-05-25
created: 2025-05-28
description:
tags:
  - "clippings"
---
257[tech](https://zenn.dev/tech-or-idea)

## TL;DR

- Dockerは仮想化であるコンテナの実装の一種
- ただし、広義のDockerはOCI系コンテナの総称
- アプリの配布と実行の仕組みと思えばOK
- コンテナによりIaCや一貫したデプロイ、H/Wの効率的な利用がしやすくなる

**※ コメントでいくつか指摘があったので記事を更新しました。ご指摘ありがとうございました！**

## はじめに

おそらく過去幾度となく生み出されたであろうDocker解説記事となります。正確には解説動画の解説記事。

というのも、Dockerあるいはコンテナはもはや当たり前、と言えるほど普及してるようにも **SNSやブログとかだけ** 見てると思えますが、 **実際には話題は知ってるけど良く分かってない/業務で今度使う事を検討したいけどつまり何なの？ って人もまだまだ多い** です。

なので私が **「Dockerって何？」** と聞かれたとき答えてる内容を動画にしてみました。技術的な詳細を解説というよりは **「そもそも何なの？」** **「何で流行ってるの？」** を話しています。

動画で使っているスライドはこちら。

ただ動画の中では長さの都合で話さなかったこともあるので、もう少しだけ詳細を書いておこうと思い解説の解説としてこの記事を書きました。

## Dockerとは？

Dockerは [Docker社](https://www.docker.com/company) によって開発されるOCI系のコンテナです。元々、Docker社は **dotCloud** というPaaSベンダーで、フルスクラッチでアプリを作る場合のプラットフォームとして当時人気だったのHerokuとは異なり、 **WordPressとか既存のアプリケーションのホスティング** を簡単に出来ることを売りにしていました。その中で使われていた技術がDockerコンテナであり、こちらを公開したところ **本業よりも人気** になってしまい社名もDocker社に改めて本格的にコミットしてきました。

コンテナという存在はDocker以前にもありましたが、既存のものより **ポータビリティ** に優れ、この段階では後述する **Vagrantの後継** としてちょうど良いポジションだったのでまず普及したかな、という感じがります。もちろん他の文脈で気にしてた人も当時からいると思いますけど。

もう一つ重要な点としてDockerは具体的な実装としてのDockerとは別にOCI系コンテナの総称としても使われます。例えば **本番環境でDockerを使っているとは限らず** 実は別の実装(例えばcontainedとか)を使う事も少なくないのですが **便宜上「Dockerを使ってる」と言ったり** します。これは後述する **OCIと呼ばれる仕組み自体がDockerをオープン化したもの** であり、その流れから **広義にはDockerはOCI系コンテナの総称** となります。正確な表現かはさておきとして、実際問題OCI系のコンテナの総称として使われることもあるので **「狭義のDockerと広義のDockerがある」** といったん覚えてもらえれば良いかと思います。

Dockerは本番環境では単体ではなく **k8s(Kubernetes)** と組み合わせて使われることが多いです。この組み合わせが **モダンなインフラを作る基礎技術** になっているので現在メチャクチャ流行っている、という訳です。また\*\*「Dockerって何？」\*\* という話題になった時に、ポータビリティだったりIaCだったり分散システムだと話が発散しがちなのですが、これは元々 **色々な文脈のプラクティスがDockerに合流** しているためです。その点に関しては後半で説明をします。

## コンテナとは？

## コンテナ概要

コンテナは **OS機能による仮想化** の一種です。最近よく聞く名前だと思いますが特に新しい技術ではなく **何十年も前からある仕組み** です。SolarisのZONE、BSDのJail、あるいはLinuxのLXCやOpenVZなど様々なコンテナがあり活用はされてきたのですが、今は **コンテナといえばOCI系コンテナを指す** と言っても過言ではないと思うので、特別な文脈でなければ「コンテナ == OCI系コンテナ」と思って聞いて大丈夫だと思います。この記事でも以降は単にコンテナと呼びます。

コンテナは **OSの仮想化** とも呼ばれますが、VMWareなどの **H/W仮想化** とは異なり、 **OSそのものは共有** しているが **名前空間の分離やリソースの割り当て** を分離しています。そのため **オーバーヘッドが非常に小さく** ほとんど普通のプロセスと同様の速度で起動/実行されます。

OS（正確には狭義のOSであるカーネル）を共有するのでVMWare等のように **自由にゲストOSを選ぶことは出来ません** 。OS機能を使ってるのでホストOSも通常は限定されます。Dockerの場合はLinuxをベースとした仕組みなので **原則Linuxのみで動作** します。厳密に言えばWindows ContainerというOCIに準拠したWindowsのコンテナもあります。しかしWindowsサーバを運用する上での主流という感じではないです。とはいえ、コンテナ周りもどんどん発展しており今後Linuxベースでは無いものも普及はしてくるかもしれませんが、現時点ではLinuxベースのものと考えて良いと思います。余談ですが **Windowsの内部では** WSL2やDefender Application Guardなどコンテナは結構使われてたりします。内部で使うだけなら必要が無いのでそれらはOCI準拠という分けでも無いでしょうけど。

「いや、 **うちのMacやWindowsはDocker使えてるよ？** 」と思われるかもしれませんが、あれは **Docker Desktop** がVitual Boxや各種OSの仮想化機能を使って **H/W仮想化でLinuxを動かしてその上でDockerを動かして透過的につないでる** だけです。Windowsの場合はHyper-vと組み合わせてOCI準拠の形でLinuxを動かす [runhcs](https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/containerd) という形で仕様としてもまとめられています。非常に便利な仕組みですね。ただ、Linux以外のホストOSでLinuxコンテナを動かしてる場合は大なり小なり仮想環境を挟んでいるので、意識してないと偶に罠にはまりますので注意をしてください。

## H/W仮想化とコンテナ

H/W仮想化とコンテナの違いをもう少し追っていきましょう。良くある説明の図はこんな感じ。  
![](https://storage.googleapis.com/zenn-user-upload/gi53vb9j8wu3pkpd86pkgj11bqza)

H/W仮想化ではまず **ハイパーバイザー** が一番下に置かれます。その上で各種ゲストOSが動く形ですね。ハイパーバイザーとは雑に言えば「 **仮想マシン専用の実行基盤(=OS)** 」です。通常のOSよりも仮想マシンの実行に特化しているので **無駄なものが無くセキュアで軽く高機能** 、というわけです。 **VMWare ESXi** が一番有名だと思います。

本当はH/W仮想化も **ハイパーバイザー方式以外** にもType2とも呼ばれるQEMUやVirtualBoxなどOSのアプリケーションとして動く仮想化ソフトウェアもあるのですが、サーバサイドでは通常はハイパーバイザー方式を採用するのでそちらと比較しています。

ハイパーバイザがその上で各マシンをエミュレーションしその上にOSをデプロイしているのに対し、コンテナの場合は同じOSの上にコンテナという箱を置いてそこで **アプリ単位での仮想化** を実行しています。図を見るだけでも **パソコン/サーバを丸ごとエミュレーションしているH/W仮想化** よりは **アプリの実行のところだけ仮想化しているコンテナ** の方がなんとなく **オーバーヘッド小さそう** ですよね？

具体的な **仮想化対象の違い** は以下の通り。  
![](https://storage.googleapis.com/zenn-user-upload/jhhor9ru2oir3u7z1k1sy8akwoxu)

図の通り、H/W仮想化ではCPUやメモリといったものを仮想化しています。そのため **仮想マシンより上は通常のOS** になり **WindowsとLinuxをそれぞれGuest OSで動かしたりすることも可能** です。準仮想化の話とかあるけどここでは割愛。

対して **コンテナでの仮想化** の基本は **名前空間の分離** です。これは **同じOSの上にあるのにそれぞれのアプリを専用環境で動かしているように見える** という事です。例えば利用するディレクトリ及びインストールされているソフトウェアが異なっていたり、コンテナ間でプロセスが共有されなかったり、NWで同じIPやポートを使っても干渉しなかったり、そういったOS  
**OSの各種機能が隔離されている** という事です。また **CPUやメモリ、ストレージといったリソースの割り当ても制御** します。

コンテナはあくまでOSの各プロセスにタグのようなものを付けコンテナ間で干渉しないようにフィルタリングしているような挙動になります。実際にDockerなどであれば **ホストOSでPSコマンドを打てばDocker上のプロセスも通常のプロセスのように見えます** 。H/W仮想化でも仮想マシンの上で動くプロセスを確認は出来ますがこれは仮想マシンの上で動くOSをのぞき込んでるだけでコンテナのケースとはかなり挙動が違います。この違いがパフォーマンスやセキュリティに大きな影響を与えています。

## イメージとコンテナ

Dockerの基本となるDockerfile/イメージ/コンテナについて解説します。  
![](https://storage.googleapis.com/zenn-user-upload/x7g7gt1gyrsmjsnjdfkk6zanj74a)

まず、Dockerfileですがこれはビルドスクリプトです。Dockerではマニュアル片手にコンテナにログインしてコマンドを手作業で打って環境構築、ということは通常はしません。代わりにDockerfileというBash風のビルドスクリプトを使います。これによって手順書でインフラを作るよりも誰が作っても再現性の高い環境を構築できます。このような考え方を **IaC (Infrastructure as a Code)** と呼びます。AnsibleとかChefとか使ったことがある人はイメージがしやすいですね。ビルド結果としてimageが出来ます。

次にimageですが、これは **Linuxのディレクトリを/からtarで固めたもの** と考えてみてください。実際にはDockerはLayerd File Systemを採用しているので単一のファイルとして固められてるわけではないのですが/から固めたファイル全部と考えた方が想像しやすいのでまずはそう考えても良いと思います。LinuxといえばRedhatやCentOS、DebianやUbuntuなど **様々なディストリビューションがありますがカーネルは同じ** です。そのためルートからのディレクトリを丸ごと置き換えてやれば異なるディストリビューションとして振舞います。またイメージの最も重要な点は **「配布可能」** という事です。これにより **Write once, Run anywhere** をいかなる言語であっても実現する事が出来ます。

最後にContainerですがこれはImageを実行した状態と考えることが出来ます。ImageとContainerは最初はどっちがどっちだったかと混乱しがちですが、ディスクイメージのような塊がImage、実際に動いてるプロセスがContainerと考えると良いと思います。

## Dockerが流行っている理由

## Dockerで出来ること

簡単に構成の話が出来たので、次にDockerで出来る事を解説します。シンプルに言えば以下の３つです。

- DockerfileでImageを作成できる
- Docker Imageを配布できる
- Docker Imageをコンテナとして隔離された形で実行できる

という3点です。つまるところ **アプリを必要なライブラリごとパッケージング** して、 **配布** して **環境に依存せずに実行** できます。さて、ではなぜこの特徴でここまで流行っているのでしょうか？

![](https://storage.googleapis.com/zenn-user-upload/dwjq9o8gx2bmzkwfswuph6pi7uca)

端的にいえば **Dockerは流行っているから流行っています** 。

DockerHubやk8sといったエコシステムの力を使いたいから流行っているのです。もちろん、そのエコシステムが出来上がったのには理由があり、それこそが最初に上げたDockerの特徴です。この特徴が有用だったでのDocker以前から存在していた **様々なプラクティスがDockerに集約** されていきました。

## Docker前史

先ほど述べたようにDockerは様々なプラクティスが集約されています。つまり目的が分かりづらいです。なので、Dockerに集約される前の前史を振り返ってみます。

![](https://storage.googleapis.com/zenn-user-upload/tefhbld154dmpf85sf2d1m09sw4e)

運用/インフラ/あるいはDevOpsという界隈では上記の4つの考え方があり10年くらい色んな製品が群雄割拠していました。

### パッケージング/ポータビリティ

これは依存関係を含めて一つに固めてそれを配布すればどこでも動く、ということです。一番成功した例はJavaEEのwarではないでしょうか？ あるいはRubyのエンジニアならばbundler, Pythonのエンジニアであればpipenvを思い浮かべても良いと思います。これらは単一ファイルまたはディレクトリに依存を固めることでポータビリティを実現しています。ただし課題もあって多くの場合はOSのグローバル環境にも依存していしまいます。 `/var` や `/etc` あるいはホームディレクトリなどの構成やIPアドレスにポート番号、また自前主義のJavaはともかくスクリプト言語だとOSにインストールされているパッケージも重要です。こういったところで差分が出てしまいポータビリティには課題が残る状態でした。これを解決するために仮想OSに固めてVMイメージを配布する **Vagrant** というソフトも人気を博していましたが、Dockerに比べると起動のオーバーヘッドやイメージが大きかった状態です。

### IaC (Infrastructure as a Code)

先ほども説明した通り手作業ではなくスクリプトでインフラを組む考え方です。これは手順書の代わりに構築を自動化させて作業を効率化させるという観点もあるのですが、どちらかというとバージョン管理や簡単なdiffの確認、PullRequest/コードレビューなど開発のベストプラクティスをインフラにも持ち込むための考え方です。AnsibleやChefも有名ですね。Iacにより手順書やパラメータシートを疑って本番で値を確認しなくても良くなります。特にその中でもDockerは一度作った環境を変更しない **Immutable Infrastructure** と呼ばれる運用を実現できます。実はAnsibleやChef、あるいは特に自前のBashによる環境構築をした場合は手で誰かが後から変更してしまったり、スクリプトに不備があった時に **誤った変更** をしてしまい環境を壊す場合がありました。Immutable Infrastructureでは変更では無く常に新規構築なので誤った場合に元の内容に戻すのも容易です。

### サーバ利用効率化

ハードウェアをより有効活用しよう、という話です。現在のサーバはスペックが高く通常時は空きリソースが出来るのは当然です。そしてクラウド時代と違いHWは貴重なので、アプリケーションを相乗りさせてHWリソースを有効活用しようという話になりました。しかしながら、素朴な相乗りでは同一のライブラリの異なるバージョンを要求して片方のアプリが壊れたり、セキュリティ設定があまいだと別チームの人間が別アプリを触れたり、そして何より片方のアプリが高負荷な時に巻き込まれて死ぬ、という事象が発生していました。これらを解決するためにOSレベルのセキュリティ/リソースの分離をすべくVMwareなどの仮想化が普及していきました。特にVMWareは２つの異なるアプリケーションが同時に高負荷になる可能性は低い、という特性に注目して単にに2で割ったリソース分配ではなく少し多めにリソースを割り当てるオーバーコミットをする事が出来ます。 **銀行の信用想像みたいなもの** です。 **皆が一斉に引き出す(=一斉に高負荷)と取り付け騒ぎ** になるのも同様ですね。

### オーケストレーション

この文脈では大規模分散システムのリソース管理を指します。これはある意味ではH/W仮想化を使ったサーバ利用効率化をより推し進めたものでOSのスケジューラよりもよりたくさんの必要な情報をとれるためミドルウェアとして実装され対応したアプリケーションのスケジューリングを行っていました。有名な実装としてHadoop YARNやMesosがあります。

こういった様々な観点がDockerとK8sに集約されていき、現在は上記の４つのいずれかを実践したい場合は最新の環境がDocker + k8sになるので人気があるわけです。まあ、最新の仕組みが一番自分たちに合うかどうかは別の話だけど。  
![](https://storage.googleapis.com/zenn-user-upload/ij3qbqid02kyi3xq5obkhdoh4f9t)

## Dockerの周辺システム

## DockerHub

![](https://storage.googleapis.com/zenn-user-upload/2n68nlfmpfustnmofkba4hpa2ood)

**DockerHubはDockerイメージを共有するための仕組み** です。DockerにはRegistryというイメージを配布する仕組みがあり、DockerHubはその本家本元公式サイト、というわけです。DockerHubの公開済みイメージを使う事で今まではそれなりに手間がかかったMySQLやMongoDBなどのミドルウェア、あるいはそれらも利用したWordPressのようなアプリケーションが今や `docker run` の一発で構築できるようになりました。これはメチャクチャ強力です。Dockerが流行った原動力の一つはこのDockerHubの豊富な充実度だと思っています。

## k8s (Kubernetes)

![](https://storage.googleapis.com/zenn-user-upload/s5k60hxducdv0owr5a9d5hd2hfpk)

k8sは非常に大きく複雑な仕組みなのであまり触れませんが、オーケストレーションを担当するミドルウェアになります。つまりDockerを使った分散環境です。色々機能はありますが **主にスケジューリング/デプロイ/セキュリティを担当** します。つまりYARNやMesosのような位置づけですね。Googleが社内で利用していたBorg/Omegaといった大規模コンテナ実行基盤をベースに、Dockerに対応できるように一から書き起こしたものです。元々コンテナの超ヘビーユーザであるGoogleによって作られただけあって拡張性が非常に高くかつスケーラブルです。

分散環境で自由度の高いスケジューリングを行おうとすると **配下のどのノードにもデプロイでき依存無く実行される必要** があります。これにはDockerの特徴は最適です。

ただ、私の認識ですがk8sはPaaSなどのクラウド環境を作る基盤という特性が強いので自力で運用しようとするとかなりのパワーを使います。そのため素のk8sを直接運用するよりもCloud RunやHerokuのようなPaaS/CaaSとして利用できる別のコンテナ実行基盤や、AWS FargateやGKE Autopilotのようにフルマネージドなk8sか、せめてGKEやAmazon EKSを使うのが良いと個人的には思います。前から順番にお勧め。もちろん、必要なら素のk8sを選べばいいと思います。

## Docker以外のOCIコンテナ

![](https://storage.googleapis.com/zenn-user-upload/y7emsptvnh8oykwellgj9ss0vatr)

OCIは元々Dockerをオープン化した仕様となります。さらにリファレンス実装の多くが元々Docker由来という事もあってOCI系コンテナの総称としてDockerを使うというのはすでに述べた通りです。逆にいえばDocker以外の実装も存在します。

有名どころとしてはcontainerd, cri-o, そしてPodmanです。

containerdは実はDockerの内部にも使われている実装でいわばDockerから本番実行に不要な部分を外したコードです。そのためDockerとの互換性も非常に高くGKE, EKS, AKSなどでもサポートされています。

cri-oはその登場経緯からしてk8sで動かすことを目的として作られました。そのため軽量でk8sで動かすことに特化しているそうです。OpenShiftなどで利用されています。

最後にPodmanですがRedhat社がDockerの代替を狙って開発しているコンテナです。Docker同様に開発ツールなのでビルドなどの機能も充実しています。大きな特徴として不要なデーモンプロセスを無くしたりsystemdとの連携を高めるなどセキュリティやLinuxとの統合をより進めたプロダクトとなっています。

## Dockerとセキュリティ

Dockerにおいてセキュリティは重要なキーワードです。それは原理的にOSを共有しているためVMWareなどのH/W仮想化に比べると隔離レベルが低いからです。これは社内などすべてのコンテナが自社のもののケースでは問題になりにくいですが、クラウドベンダーなど複数のユーザのワークロードを混在して実行させる環境では大きな問題になることもあり得ます。

そのためいくつかのセキュリティのための実装があります。特に有名なのがAmazonのFirecrackerとGoogleのgVisorです。これらはAWSやGCPなどで既に利用されています。

[Firecracker](https://firecracker-microvm.github.io/) は分かりやすくmicro-VMとも呼ばれる非常に小さなVMを起動しその上でコンテナを動かすのに必要最小限のLinuxを動かす方式です。micro-VMは1秒以下の時間で起動する非常に高速な実装なのでVMwareとかでイメージする仮想マシンの起動速度とは一線を画します。WindowsのWSL2とかもそうですね。VMなので隔離レベルは高くシンプルですし、それでいて起動が高速なのは素晴らしいです。なお [Firecracker はコンテナランタイムではない](https://blog.8-p.info/ja/2020/12/27/fc-and-fccd/) ので注意をしてください。

[gVisor](https://gvisor.dev/) はユーザ空間で動くアプリケーションとして実装されたカーネルです。コンテナ側から見えるカーネルを直接ホストのカーネルではなくコンテナ毎に専用のカーネルで実行します。最終的にはこのgVisorのカーネル自体はホストのカーネルの上で動くことになりますが直接コンテナから見えませんし強力なセキュリティとパフォーマンスを両立できます。一方でmicro-VMと比べると仕組みが複雑になりがちかと思います。

Dockerとセキュリティ、というと脆弱性スキャンの話も話題になりがちですが、今回はコンテナに特化した事情というこでカーネル周りの話をもってきました。

## まとめ

なるべく技術的な詳細には踏み込まずにかつ使いたい理由/流行っている理由をまとめてみました。とりあえず一通り読むと以下のイメージが大分つきやすくなったんじゃないでしょうか？

- Dockerは仮想化であるコンテナの実装の一種
- ただし、広義のDockerはOCI系コンテナの総称
- アプリの配布と実行の仕組みと思えばOK
- コンテナによりIaCや一貫したデプロイ、H/Wの効率的な利用がしやすくなる

OCIとかRunCとかCRIとか技術的な背景が知りたいんだー！ って人には物足りないと思いますし、コマンドでの操作とか実務的な内容は別でやる必要がありますけど **「そもそも何？」** って段階だと、このくらいがちょうど良いんじゃないかな、と。

ちなみにこれはかなりジェネラルな説明で相手の知識によってもちろんカスタマイズします。特にJava EEとかに慣れてる人だったら「 **war=docker, k8s=weblogic/glassfishととりあえず思ってください** 」という事が多いかな。

それではHappy Hacking!

## 参考

この記事はあまり細かい所を深堀していないので以下の資料も読むとより詳しく分かるかと思います。

257